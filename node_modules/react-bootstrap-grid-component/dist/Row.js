import * as React from 'react';
import prefixes from './PrefixManager';
import './sizingbreakpoints.scss';
var viewportClassPrefix = function (viewport) { return (viewport === 'xs' ? '' : '-' + viewport); };
function setAlignment(alignmentValue) {
    return typeof alignmentValue === 'string' ? { xs: alignmentValue } : alignmentValue || {};
}
function populateClasses(alignmentBreakpointsType, propertyName) {
    var classNames = [];
    Object.keys(alignmentBreakpointsType).forEach(function (breakpointName) {
        var breakpointValue = alignmentBreakpointsType[breakpointName];
        classNames.push("" + prefixes.column + propertyName + viewportClassPrefix(breakpointName) + "-" + breakpointValue);
    });
    return classNames;
}
export var Row = function (_a) {
    var verticalAlignment = _a.verticalAlignment, horizontalAlignment = _a.horizontalAlignment, noGutters = _a.noGutters, children = _a.children, className = _a.className;
    var classNames = [prefixes.row + "row"];
    var verticalAlignmentBreakpoints = setAlignment(verticalAlignment);
    var horizontalAlignmentBreakpoints = setAlignment(horizontalAlignment);
    if (verticalAlignment) {
        var verticalAlignmentClassNames = populateClasses(verticalAlignmentBreakpoints, 'align-items');
        classNames.push.apply(classNames, verticalAlignmentClassNames);
    }
    if (horizontalAlignment) {
        var horizontalAlignmentClassNames = populateClasses(horizontalAlignmentBreakpoints, 'justify-content');
        classNames.push.apply(classNames, horizontalAlignmentClassNames);
    }
    if (noGutters) {
        classNames.push(prefixes.row + "no-gutters");
    }
    if (className) {
        classNames.push(className);
    }
    return React.createElement("div", { className: classNames.join(' ') }, children);
};
//# sourceMappingURL=Row.js.map